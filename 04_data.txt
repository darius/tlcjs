:chap_num: 4
:prev_link: 03_functions
:next_link: 05_higher_order


= Compound Data: Objects =

////

Outline:

- introduce flat objects as way to collect different data together.
- match this against domain modelling. ie, if we have a book, we may
  have a title, author, pub year, which naturally models as
  { title : string, author : string, year: number }
- some examples using that (and the design recipe!)
- introduce bigBang, showing how you can use it, and images, to make
  games!
- extended examples and then extended exercise building a real game!

////


Note: We're not sure what this illustration is for, but maybe it will gain some purpose.

image::img/weresquirrel.png[alt="The weresquirrel"]

Numbers, booleans, images, and strings are all really useful, and
allow us to write interesting programs! But, alone, they have some
limitations. In particular, sometimes we want to talk about different
pieces of data together. In the previous chapter, we talked about
modelling the shape of the information in our program after what we
are trying to represent in the real world. Sometimes, we can represent
something as _just_ a number, or _just_ a string, or _just_ an image,
but often we want to _combine_ them together.

For example, if I want to write a program that I use to organize
books, I will want to have some notion of a `book` in the program. I
could try to figure out a way to represent it with just a string
(perhaps an ISBN?), but realistically, I probably want a bit more
information. To do this, Javascript allows us to construct
`objects`. An object is a collection of fields, where each field has a
name and a value within it. For example, if I wanted to represent the
book "The Left Hand of Darkness", I might write:

[source,javascript]
----
var lhod = { title: "The Left Hand of Darkness",
             author: "Ursula K. Le Guin",
             year: 1969
           };
----

Objects are written with a `{`, then a series of field, colon, value
clauses, each separated from one another with a comma. New lines
between the fields are not necessary, but are often used to make it
easier to read. We could (but shouldn't) have written the above as:

[source,javascript]
----
var lhod = {title:"The Left Hand of Darkness",author:"Ursula K. Le Guin",year:1969};
----

When following the design recipe, we write them in signatures in a
similar way, with fields, colons, and then the signature for what goes
into that field. For example, we might write the above as:

[source,javascript]
----
// A book is { title: string, author: string, year: number}
----

As in the above example, we can store objects in variables, and we can pass them to functions. To get the fields out, we use `.` followed by the name of the field. For example:

[source,javascript]
----
var lhod = { title: "The Left Hand of Darkness",
             author: "Ursula K. Le Guin",
             year: 1969
           };
print(lhod.title);
----

Since objects are values like strings, numbers, and images, we can put
objects into fields of other objects. For example

[source,javascript]
----
var lhod = { title: "The Left Hand of Darkness",
             author: {first: "Ursula K.", last: "Le Guin"},
             year: 1969
           };
print("The first name is: " + lhod.author.first);
----

The signature for this is:

[source,javascript]
----
// { title: string,
//   author: { first : string, last: string }
//   year: number
// }
----

== Big Bang ==

The majority of this chapter is an extended example using objects, the
tools we've learned so far, and a new, more powerful verion of
`animate` that allows us to build interactive games. This function is
called `bigBang`. The idea of big bang is to construct an animation,
but to allow you more control over it than you had with `animate`.

You can try out the finished example here (by the end of the chapter,
you will be able to build similar, and better, games!):

http://tlcjs.org/games/flappy.html[_http://tlcjs.org/games/flappy.html_]

So, let's get into it!

In `animate`, your function was called with a number (that represented
the number of _ticks_ since the animation started), and it returns an
image. With `bigBang`, you get to define what the _world state_ is
that you get passed each time (in `animate`, the world state was a
number), and you get to define how it changes each time step (with
`animate`, the world state, which is a number, was incremented by one
each time step). There is also a way to respond to keyboard input.

`bigBang` takes four arguments, and the first argument is the initial
world state (which, if you were replicating `animate`, would be the
number 0). The second argument is the same as `animate` - it is a
function that takes your world (in `animate`, a number) and produces
as output an image which will get drawn. The third argument is a
function that takes the current world state as input and produces the
new world state as output (in `animate`, this function just adds `1`
to its input). The last argument is completely new: it is a function
that takes as input the current world state and a string that
represents a key that was pressed on the keyboard, and produces a new
world state. This makes it so that your "animations" can respond to
keyboard input (which makes them interactive! And can be games).

To review, we can use `bigBang` to replicate the way that animate worked:


[source,javascript]
----
animate(function (ticks) {
  return placeImage(circle(10, "red"), emptyScene(400,100), ticks, 70);
});
----


[source,javascript]
----
bigBang(0,
        function (ticks) {
          return placeImage(circle(10, "red"), emptyScene(400,100), ticks, 70);
        },
        function (world) { return world + 1; },
        function (world, key) { return world; });
----

But we can, and will, do so much more with it!

First, lets talk a little bit about Flappy Bird.

Looking at what is on the screen at a given time, we can see the bird
and the two pipes. Since both of those move over time, it seems like
we need to be able to keep track of where they are. To start, we won't
worry about the pipes, and will only focus on moving our bird up and
down. Since we only go up and down, we really just need to know how
high the bird is, which is just a number. But since we are going to
make this more complicated, and since this is the chapter about
objects, we'll start with a javascript with one field:

[source,javascript]
----
// world state is { bird_position : number }
----

Now we want to figure out how to draw the scene with the bird on
it. You can make a much better drawing, but for our example, we'll
build a simple bird and draw it:

[source,javascript]
----
var eye = circle(5, "white");
var mouth = placeImage(circle(10, "rebeccapurple"), circle(10, "white"), 0, -5);
var character = placeImage(mouth, placeImage(eye, rectangle(50, 50, "rebeccapurple"), 30, 10), 40, 20);
var ground = placeImage(rectangle(600, 10, "brown"), emptyScene(600, 400), 0, 390);

// { bird_position : number } -> image
function drawWorld(world) {
  return overlay(character, ground);
}

print(drawWorld({bird_position: 0}));
----

That worked, and it put our character on the background, but it didn't
use the `bird_position`, and as a result, calling it with different
positions doesn't change the image! Not good.

So we should have `drawWorld` vary where the bird is based on the
`bird_position` field in the world state.

[source,javascript]
----
var eye = circle(5, "white");
var mouth = placeImage(circle(10, "rebeccapurple"), circle(10, "white"), 0, -5);
var character = placeImage(mouth, placeImage(eye, rectangle(50, 50, "rebeccapurple"), 30, 10), 40, 20);
var ground = placeImage(rectangle(600, 10, "brown"), emptyScene(600, 400), 0, 390);

// { bird_position : number } -> image
function drawWorld(world) {
  return placeImage(character, ground, 200, world.bird_position);
}

print(drawWorld({bird_position: 50}));
print(drawWorld({bird_position: 200}));
----

And now we can see how the image varies (the bird is further from the
top, as `placeImage` takes the distance from the left and distance
from the top - see the Reference for more detail).

Looking back at `bigBang`, we now have a world state definition (and
the initial state could be `{bird_position: 0}`), we have a way of
drawing the world, so we need two more things: how the world changes
over time, and how it changes based on keyboard input.

To start, lets not worry about gravity, so the only change is based on
keyboard input (which means that the function with signature `world ->
world` that controls how the world changes each time tick is just
`function onTick(world) { return world; }` - the function that does
nothing and returns its argument). That function takes the world state
and a string that represents a key that was pressed. For our purposes,
the only one that matters is "Space", which means the spacebar was
pressed.


[source,javascript]
----
var eye = circle(5, "white");
var mouth = placeImage(circle(10, "rebeccapurple"), circle(10, "white"), 0, -5);
var character = placeImage(mouth, placeImage(eye, rectangle(50, 50, "rebeccapurple"), 30, 10), 40, 20);
var ground = placeImage(rectangle(600, 10, "brown"), emptyScene(600, 400), 0, 390);

// { bird_position : number } -> image
function drawWorld(world) {
  return placeImage(character, ground, 200, world.bird_position);
}

// { bird_position : number } -> { bird_position : number }
function onTick(world) {
  return world;
}

// { bird_position : number }, string -> { bird_position : number }
function onKey(world, key) {
  if (key === "Space") {
    var newPosition = world.bird_position + 1;
    return { bird_position : newPosition };
  } else {
    return world;
  }
}

bigBang({bird_position: 0}, drawWorld, onTick, onKey);
----
