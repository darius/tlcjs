:chap_num: 4
:prev_link: 03_functions
:next_link: 05_higher_order


= Compound Data: Objects =

///

Outline:

- introduce flat objects as way to collect different data together.
- match this against domain modelling. ie, if we have a book, we may
  have a title, author, pub year, which naturally models as
  { title : string, author : string, year: number }
- some examples using that (and the design recipe!)
- introduce bigBang, showing how you can use it, and images, to make
  games!
- extended examples and then extended exercise building a real game!

///


Note: We're not sure what this illustration is for, but maybe it will gain some purpose.

image::img/weresquirrel.png[alt="The weresquirrel"]

Numbers, booleans, images, and strings are all really useful, and
allow us to write interesting programs! But, alone, they have some
limitations. In particular, sometimes we want to talk about different
pieces of data together. In the previous chapter, we talked about
modelling the shape of the information in our program after what we
are trying to represent in the real world. Sometimes, we can represent
something as _just_ a number, or _just_ a string, or _just_ an image,
but often we want to _combine_ them together.

For example, if I want to write a program that I use to organize
books, I will want to have some notion of a `book` in the program. I
could try to figure out a way to represent it with just a string
(perhaps an ISBN?), but realistically, I probably want a bit more
information. To do this, Javascript allows us to construct
`objects`. An object is a collection of fields, where each field has a
name and a value within it. For example, if I wanted to represent the
book "The Left Hand of Darkness", I might write:

[source,javascript]
----
var lhod = { title: "The Left Hand of Darkness",
             author: "Ursula K. Le Guin",
             year: 1969
           };
----

Objects are written with a `{`, then a series of field, colon, value
clauses, each separated from one another with a comma. New lines
between the fields are not necessary, but are often used to make it
easier to read. We could have (but shouldn't) written the above as:

[source,javascript]
----
var lhod = {title:"The Left Hand of Darkness",author:"Ursula K. Le Guin",year:1969};
----

When following the design recipe, we write them in signatures in a
similar way, with fields, colons, and then the signature for what goes
into that field. For example, we might write the above as:

[source,javascript]
----
// A book is { title: string, author: string, year: number}
----

As in the above example, we can store objects in variables, and we can pass them to functions. To get the fields out, we use `.` followed by the name of the field. For example:

[source,javascript]
----
var lhod = { title: "The Left Hand of Darkness",
             author: "Ursula K. Le Guin",
             year: 1969
           };
print(lhod.title);
----

Since objects are values like strings, numbers, and images, we can put
objects into fields of other objects. For example

[source,javascript]
----
var lhod = { title: "The Left Hand of Darkness",
             author: {first: "Ursula K.", last: "Le Guin"},
             year: 1969
           };
print("The first name is: " + lhod.author.first);
----

== Big Bang ==

The majority of this chapter is an extended example using objects, the
tools we've learned so far, and a new, more powerful verion of
`animate` that allows us to build interactive games. This function is
called `bigBang`. The idea of big bang is to construct an animation,
but to allow you more control over it than you had with `animate`.

You can try out the finished example here (by the end of the chapter,
you will be able to build similar, and better, games!):

http://tlcjs.org/games/flappy.html[_http://tlcjs.org/games/flappy.html_]

So, let's get into it!

In `animate`, your function was called with a number (that represented
the number of _ticks_ since the animation started). With `bigBang`,
you get to define what the _world state_ is that you get passed each
time (in `animate`, the world state was a number), and you get to
define how it changes each time step (with `animate`, the world state,
which is a number, was incremented by one each time step).

`bigBang` takes four arguments, and the first argument is the initial
world state (which, if you were replicating `animate`, would be the
number 0). The second argument is the same as `animate` - it is a
function that takes your world (in `animate`, a number) and produces
as output an image which will get drawn. The third argument is a
function that takes the current world state as input and produces the
new world state as output (in `animate`, this function just adds `1`
to its input). The last argument is completely new: it is a function
that takes as input the current world state and a string that
represents a key that was pressed on the keyboard, and produces a new
world state. This makes it so that your "animations" can respond to
keyboard input (which makes them interactive! And can be games).

To review, we can use `bigBang` to replicate the way that animate worked:


[source,javascript]
----
animate(function (ticks) {
  return placeImage(circle(10, "red"), emptyScene(400,100), ticks, 70);
});
----


[source,javascript]
----
bigBang(0,
        function (ticks) {
          return placeImage(circle(10, "red"), emptyScene(400,100), ticks, 70);
        },
        function (world) { return world + 1; },
        function (world, key) { return world; });
----

But we can, and will, do so much more with it!
